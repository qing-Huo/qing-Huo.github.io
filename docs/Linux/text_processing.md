# 文本处理

## 文本处理

- cat –连接文件并且打印到标准输出
- sort –给文本行排序
- uniq –报告或者省略重复行
- cut –从每行中删除文本区域
- paste –合并文件文本行
- join –基于某个共享字段来联合两个文件的文本行
- comm –逐行比较两个有序的文件
- diff –逐行比较文件
- patch –给原始文件打补丁
- tr –翻译或删除字符
- sed –用于筛选和转换文本的流编辑器
- aspell –交互式拼写检查器

### 查看文本
- cat less more head tail........
  * ```cat```会一次性输出，不支持翻页，适合查看小文本
  * ```less```比较常用，操作同vim
  * ```head```默认查看文件头10行, ```head -n 20 filename```查看头20行
  * ```tail -f```实时检测文本

### 查找文件
- locate find
  * ```locate [查找路径] [文件名的关键字]```,此命令wsl中不存在
  * ```find [查找范围] [查找条件] [动作]```
  * ```find```在指定目录下查找文件
  * ```find path -option [ -print] [ -exec -ok command] {} \;```



### 重定向和管道
- ```>```和```>>```用来输出重定向
```bash
ls -l > stdout.txt  # 若stdout.txt不存在则创建，若已存在则覆盖其内容
ls -l >> hello.c  # 在hello.c最后追加上ls -l的输出
```
- ```<```和```<<```用来输入重定向
- ```tr [准备要替换的字符] [要替换成的字符]```
- ```sort -k [关键字字段序号] [要排序的文本]```
  * ```sort```可以给文本指定分隔符排序(例如指定```.```排序IP地址)

- 管道不会传递错误输出
- ```grep```一个文本搜索工具，可以配合正则(筛选文本)
  * ```geep [关键字] [目标文件]```
- ```wc```文本统计(统计字符数，字节数，行数，结尾符也计入)
- ```uniq```文本去重(只能去除连续行的重复，可以和```sort```绑定使用)

### cut
- ```cut```文本切割,在每个文件FILE的各行中，把提取的片段显示在标准输出
```bash
cut [参数] [数值区间] 文件
  -b    以字节为单位分割
  -n    取消分割多字节字符，与-b一起用
  -c    以字符为单位
  -d    自定义分隔符，默认以tab为分隔符
  -f    与-d一起使用，指定显示哪个区域
  N     第N个字节，字符或字段，从1计数起
  N-    从第N个字节，字符或字段至结尾
  N-M   从第N到第M(包括M)个字节，字符或字段
  -M    从第开始到第M(包括M)个字节，字符或字段
```

### paste

paste 命令的功能正好与cut 相反。它会添加一个或多个文本列到文件中，而不是从文件中抽取文本列。
它通过读取多个文件，然后把每个文件中的字段整合成单个文本六，输入到标准输出。
类似于 cut 命令， paste 接受多个文件参数和 / 或标准输入。

### join

在某些方面,join 命令类似于 paste,它会往文件中添加列,但是它使用了独特的方法来完成。
一个 join 操作通常与关系型数据库有关联,在关系型数据库中来自多个享有共同关键域的表格
的数据结合起来,得到一个期望的结果。这个 join 程序执行相同的操作。它把来自于多个基于
共享关键域的文件的数据结合起来。

### comm

comm 程序会比较两个文本文件,并且会显示每个文件特有的文本行和共有的文把行

### diff

类似于 comm 程序,diff 程序被用来监测文件之间的差异。然而,diff 是一款更加复杂的工具,
它支持许多输出格式,并且一次能处理许多文本文件。软件开发员经常使用 diff 程序来检查不
同程序源码版本之间的更改,diff 能够递归地检查源码目录,经常称之为源码树。diff 程序的一
个常见用例是创建 diff 文件或者补丁,它会被其它程序使用,例如 patch 程序,来把文件从一个版本转换为另一个版本。

### patch

patch 程序被用来把更改应用到文本文件中。它接受从 diff 程序的输出,并且通常被用来
把较老的文件版本转变为较新的文件版本。让我们考虑一个著名的例子。Linux 内核是由一个
大型的,组织松散的贡献者团队开发而成,这些贡献者会提交固定的少量更改到源码包中。这
个 Linux 内核由几百万行代码组成,虽然每个贡献者每次所做的修改相当少。对于一个贡献者
来说,每做一个修改就给每个开发者发送整个的内核源码树,这是没有任何意义的。相反,提
交一个 diff 文件。一个 diff 文件包含先前的内核版本与带有贡献者修改的新版本之间的差异。
然后一个接受者使用 patch 程序,把这些更改应用到他自己的源码树中。使用 diff/patch 组合
提供了两个重大优点:

1. 一个 diff 文件非常小,与整个源码树的大小相比较而言。
2. 一个 diff 文件简洁地显示了所做的修改,从而允许程序补丁的审阅者能快速地评估它。

当然,diff/patch 能工作于任何文本文件,不仅仅是源码文件。它同样适用于配置文件或任
意其它文本。

### aspell

aspell,一款交互式的拼写检查器。这个 aspell 程序是早先 ispell
程序的继承者,大多数情况下,它可以被用做一个替代品。虽然 aspell 程序大多被其它需要拼
写检查能力的程序使用,但它也可以作为一个独立的命令行工具使用。它能够智能地检查各种
类型的文本文件,包括 HTML 文件,C/C++ 程序,电子邮件和其它种类的专业文本。


### xargs 

- ```xargs```又称管道命令，构造参数等
- 给命令传递参数的一个过滤器，也是组合多个命令的一个工具
- 它把一个数据流分割为一些足够的小块，方便过滤器和命令进行处理
- 简单说：把其他命令给它的数据，传递给它后面的命令作为参数



## 格式化输出
- nl –添加行号
- fold –限制文件列宽
- fmt –一个简单的文本格式转换器
- pr –让文本为打印做好准备
- printf –格式化数据并打印出来
- groff –一个文件格式化系统

### nl 添加行号

nl 程序是一个相当神秘的工具,用作一个简单的任务。它添加文件的行数。在它最简单的用途
中,它相当于 cat -n:

### fold 限制文件行宽

折叠是将文本的行限制到特定的宽的过程。像我们的其他命令,fold 接受一个或多个文件及标
准输入。

### fmt 单间的文本格式器

fmt 程序同样折叠文本,外加很多功能。它接受文本或标准输入并且在文本流上格式化段落。
它主要是填充和连接文本行,同时保留空白符和缩进。

### pr 格式化打印文本

pr 程序用来把文本分页。当打印文本的时候,经常希望用几个空行在输出的页面的顶部或底部
添加空白。此外,这些空行能够用来插入到每个页面的页眉或页脚。

### printf Fromat And Print Data

printf 并不用于流水线执行(不接受标准输入)。在命令行中,它也
鲜有运用(它通常被用于自动执行指令中)
 。所以为什么它如此重要?因为它被广泛使用。
printf (来自短语“格式化打印”
 “print formatted”) 最初为 C 语言设计,后来在包括 shell
的多种语言中运用。事实上,在 bash 中, printf 是内置的。

### Document Formatting Systems 文件格式化系统

### groff

groff 是一套用 GNU 实现 troff 的程序。它还包括一个脚本,用来模仿 nroff 和其他 roff 家族。

roff 及其后继制作格式化文档的方式对现代用户来说是相当陌生的。今天的大部分文件都是
由能够一次性完成排字和布局的文字处理器生成的。在图形文字处理器出现之前,需要两步来
生成文档。首先用文本编辑器排字,接着用诸如 troff 之类的处理器来格式化。格式化程序的
说明通过标记语言的形式插入到已排好字的文本当中。类似这种过程的现代例子是网页。它首
先由某种文本编辑器排好字,然后由使用 HTML 作为标记语言的 Web 浏览器渲染出最终的页
面布局。

## 打印

本章需要一台正确配置的打印机来完成。

- pr ——转换需要打印的文本文件
- lpr ——打印文件
- lp ——打印文件(System V)
- a2ps ——为 PostScript 打印机格式化文件
- lpstat ——显示打印机状态信息
- lpq ——显示打印机队列状态
- lprm ——取消打印任务
- cancel ——取消打印任务(System V)

### 在 Linux 下打印

当前 Linux 系统采用两套软件配合显示和管理打印。第一,CUPS(Common Unix Printing
System,一般 Unix 打印系统)
 ,用于提供打印驱动和打印任务管理;第二,Ghostscript,一种
PostScript 解析器,作为 RIP 使用。
CUPS 通过创建并维护打印队列来管理打印机。如前所述,Unix 下的打印原本是设计成多
用户共享中央打印机的管理模式的。由于打印机本身比连接到它的电脑要慢,打印系统就需要
对打印任务进行调度使其保持顺序。CUPS 还能识别出不同类型的数据(在合理范围内)并转
换文件为可打印的格式。

### pr 转换需要打印的文本文件

在打印的历史上,基于字符的打印机曾经用过等宽字体,致使每页只能打印固定的
行数和字符数, pr 命令则能够根据不同的页眉和页边距排列文本使其适应指定的纸张。

###  将打印任务送至打印机

CUPS 打印体系支持两种曾用于类 Unix 系统的打印方式。一种,叫 Berkeley 或 LPD(用于
Unix 的 Berkeley 软件发行版),使用 lpr 程序;另一种,叫 SysV (源自 System V 版本的 Unix),
使用 lp 程序。这两个程序的功能大致相同。具体使用哪个完全根据个人喜好。

### lpr 打印文件(Berkeley 风格)

lpr 程序可以用来把文件传送给打印机。由于它能接收标准输入,所以能用管道来协同工作。

NOTE: 许多 Linux 发行版允许你定义一个输出 PDF 文件但不执行实体打印的“打印机”,
这可以用来很方便的检验你的打印命令。看看你的打印机配置程序是否支持这项配置。在某些
发行版中,你可能要自己安装额外的软件包(如 cups-pdf)来使用这项功能。

### lp 打印文件(System V 风格)

和 lpr 一样,lp 可以接收文件或标准输入为打印内容。与 lpr 不同的是 lp 支持不同的选项(略
为复杂),

### 另一种选择:a2ps

a2ps 程序很有趣。单从名字上看,这是个格式转换程序,但它的功能不止于此。程序名字的本
意为 ASCII to PostScript,它是用来为 PostScript 打印机准备要打印的文本文件的。多年后,
程序的功能得到了提升,名字的含义也变成了 Anything to PostScript。尽管名为格式转换程
序,但它实际的功能却是打印。它的默认输出不是标准输出,而是系统的默认打印机。程序的
默认行为被称为“漂亮的打印机”,这意味着它可以改善输出的外观。

### 监视和控制打印任务
由于 Unix 打印系统的设计是能够处理多用户的多重打印任务,CUPS 也是如此设计的。每台
打印机都有一个打印队列,其中的任务直到传送到打印机才停下并进行打印。CUPS 支持一
些命令行程序来管理打印机状态和打印队列。想 lpr 和 lp 这样的管理程序都是以 Berkeley 和
System V 打印系统的相应程序为依据进行排列的。


### lpstat - 显示打印系统状态

lpstat 程序可用于确定系统中打印机的名字和有效性。例如,我们系统中有一台实体打印机
(名叫 printer)和一台 PDF 虚拟打印机(名叫 PDF)

### lpq - 显示打印机队列状态
使用 lpq 程序可以查看打印机队列的状态,从中我们可以看到队列的状态和所包含的打印任
务。

### lprm 和 cancel - 取消打印任务
CUPS 提供两个程序来从打印队列中终止并移除打印任务。一个是 Berkeley 风格的(lprm),
另一个是 System V 的(cancel)。在支持的选项上两者有较小的区别但是功能却几乎相同。



## TCP概述 

RFCs: 793,1122,1323,2018,2581

- 点对点
	* 一个发送方,一个接收方
- 可靠的,按顺序的字节流
	* 没有报文边界
- 管道化(流水线)
	* TCP拥塞控制和流量控制设置窗口大小
- 发送和接收缓存
- 全双工数据
	* 在同一连接中数据流双向流动
	* MSS: 最大报文段大小
- 面向连接
	* 在数据交换之前,通过握手(交换控制报文)初始化发送方,接收方的状态变量
- 有流量控制
	* 发送方不会淹没接收方


#### TCP序号,确认号

- 序号:
	* 报文段首字节的在字节流的编号
- 确认号:
	* 期望从另一方收到的下一个字节的序号
	* 累计确认
- 接收方如何处理乱序的报文段(没有规定)


#### TCP往返延时(RTT)和超时

```
怎么设置TCP超时:
	比RTT要长
		但RTT是变化的
	太短: 太早超时
		不必要的重传
	太长: 对报文段丢失
		反应太慢,消极

怎样估计RTT:
	SampleRTT: 测量从报文段发出到收到确认的时间
		如果有重传,忽略此次测量
	SampleRTT会变化,因此估计的RTT应该比较平滑
		对几个最近的测量值求平均,而不是仅用当前的SampleRTT
```

#### TCP:可靠数据传输

```
TCP在IP不可靠服务的基础上建立了RDT
	管道话的报文段(GBN or SR)
	累计确认(像GBN)
	单个重传定时器(像GBN)
	是否可以接收乱序的,没有规范

通过一下事件触发重传
	超时(只重发那个最早的未确认段: SR)
	重复的确认
		例:收到了ACK50,之后又收到了3个ACK50

首先考虑简化的TCP发送方:
	忽略重复的确认
	忽略流量控制和拥塞控制
```

#### TCP发送方事件:

- 从应用层接收数据:
	* 用nextseq创建报文段
	* 序号nextseq为报文段首字节的字节流编号
	* 如果还没有与逆行,启动定时器
		- 定时器与最早为确认未的报文段关联
		- 过期间隔: TimeOutInterval
- 超时:
	* 重传后沿最老的报文段
	* 重新启动定时器
- 收到确认:
	* 如果是对尚未确认的报文段确认
		- 更新已被确认的报文序号
		- 如果当前还有未被确认的报文段,重新启动定时器

#### TCP流量控制

- 接收方在其向发送方的TCP段头部的rwnd字段"通告"其空闲的buffer大小
	* RcvBuffer大小通过socket选项设置(典型默认大小为4096字节)
	* 很多操作系统自动调整RcvBuffer
- 发送方限制未确认(in-flight)字节的个数<=接收方发送过来的 rwnd 值
- 保证接收方不会被淹没

#### TCP连接管理

在正式交换数据之前,发送方和接收方握手建立通信关系:
- 同意建立连接(每一方都知道对方愿意建立连接)
- 同意连接参数

#### TCP关闭连接

- 客户端,服务器分别关闭自身的连接
	* 发送FIN bit = 1的TCP段
- 一但收到FIN,用ACK回应
	* 接到FIN段,ACK看以和它自己发出的FIN段一起发送
- 可以处理同时的FIN交换

## 拥塞控制

拥塞:
- 非正式的定义:"太多的数据需要网络传输,超过了网络的处理能力"
- 与流量控制不同
- 拥塞的表现
	* 分组丢失(路由器缓冲区溢出)
	* 分组经历比较长的延迟(在路由器的队列中排队)
- 网络中前10位的问题!

#### 拥塞控制方法

2中常见的拥塞控制方法:

```
端到端拥塞控制:
	没有来自网络的显式反馈
	端系统根据延迟和丢失事件判断是否有拥塞
	TCP采用的方法

网络辅助的拥塞控制
	路由器提供给端系统以反馈信息
		单个bit置位,显示有拥塞(SNA,DECbit,TCP/IP,ECN,ATM)
		显式提供发送端可以采用的速率
```


## TCP拥塞控制: 机制

```
 端到端的拥塞控制机制
	路由器不向主机有关拥塞的反馈信息
		路由器的负担较轻
		符合网络核心简单的TCP/IP架构原则
	端系统根据自身得到的信息,判断是否发生拥塞,从而采取动作

拥塞控制的几个问题
	如何检测拥塞
		轻微拥塞
		拥塞
	控制策略
		在拥塞发送时如何动作,降低速率
			轻微拥塞,如何降低
			拥塞时,如何降低
		在拥塞缓解时如何动作,增加速率
```

#### TCP拥塞控制:速率控制方法

如何控制发送端发送的速率
- 维持一个拥塞窗口的值:CongWin
- 发送端限制```已发送但是未确认```的数据量(的上线):
	* LastByteSent - LastByteAcked <= Conwin
- 从而粗略地控制发送发的往网络中注入的速率
- ConWin时动态的,是感知到的网络拥塞程度的函数
	* 超时或3个重复的ack,CongWin ↓
		- ```超时时```:CongWin将为1MSS,进入ss阶段然后再倍增到```CongWin/2```(```每个RTT```),从而进入CA阶段
		- ```3个重复ack```:CongWin将为```CongWin/2```,CA阶段
	* 否则(正常收到ACK,没有发送以上情况):CongWin跃跃欲试 ↑
		* ```ss阶段: 加倍增加(每个RTT)```
		* ```CA阶段: 线性增加(每个RTT)```

#### TCP拥塞控制和流量控制的联合动作

联合控制的方法:
- 发送端控制```发送但未确认```的量,同时也不能超过接收窗口,满足流量控制要求
	* SendWin = min{CongWin,RecvWin}
	* 同时满足 拥塞控制 和 流量控制 要求

#### TCP拥塞控制:策略概述

拥塞控制策略:
- 慢启动
- AIMD:线性增,乘性减少
- 超时事件后的保守策略


#### 总结:TCP拥塞控制

- 当CongWin < Threshold,发送端处于慢启动阶段(Slow - start),窗口指数性增长
- 当CongWin > Threshold,发送端处于拥塞避免阶段(congestion - avoidance),窗口线性增长
- 当收到三个重复的ACKs(triple duplicate ACK),Threshold设置成CongWin/2,
	* CongWin = Threshold + 3
- 当超时事件发生时timeout,Threshold = CongWin/2,CongWin = 1MSS,进入SS阶段





## application layer 应用层

### 对等体(p2p peer to peer)体系结构
- (几乎)没有一直运行的服务器
- 任意端系统之间可以进行通信
- 每一个节点既是客户端又是服务器
  * 自扩展性-新peer节点带来新的服务能力，也带来新的服务请求
- 参与的主机间歇性连接且可以改变IP地址
  * 难以管理
- 例如: Gnutella, 迅雷

### C/S和P2P体系结构的混合体
- Napster
  * 文件搜索：集中
    - 主机在中心服务器上注册其资源
    - 主机向中心服务器查询资源位置
  * 文件传输: P2P
    - 任意Peer节点之间
- 即时通信
  * 在线监测：集中
    - 当用户上线时，向中心服务器注册其IP地址
    - 用户与中心服务器联系，以找到其在线好友的位置
  - 两个用户之间聊天：P2P

## 进程通信
- ```进程```: 在主机上运行的应用程序
- 在同一个主机内，使用```进程间通信机制```通信(操作系统定义)
- 不同主机，通过交换```报文(Message)```来通信
  * 使用OS提供的通信服务
  * 按照应用协议交换报文
    * 借助传输层提供的服务

### clients/servers
- ```客户端进程```：发起通信的进程
- ```服务器进程```：等待连接的进程
- 注意：P2P架构的应用也有客户端进程和服务器进程之分

## 分布式进程通信需要解决的问题
- 问题1：进程标示和寻址问题(```服务用户```)
- 问题2：传输层-应用层提供服务是如何(服务)
  * 位置：层间界面的SAP(TCP/IP: socket)
  * 形式: 应用程序接口API(TCP/IP: socket API)
- 问题3：如何使用传输层提供的服务，实现应用进程之间的报文交换，实现应用(```用户使用服务```)
  * 定义应用层协议：报文格式，解释，时许等
  * 编制程序，使用OS提供的API，调用网络基础设施提供通信服务传报文，事先应用时许等

#### 问题1：对进程进程编址(addressing)
- 进程为了接收报文，必须有一个```标识```
  * 即 ```SAP```(发送也需要标识)
  * 主机：唯一的32位IP地址
    - 仅仅有IP地址不能够唯一标识一个进程，在一台端系统上有很多应用进程在运行
    - 所采用的传输层协议：TCP or UDP
    - ```端口号```(Port Numbers)
    - 一些知名端口号的例子：
      * HTTP:TCP 80 Mail:TCP 25 FTP:TCP 2
- 一个进程：用IP+Port标识 端节点
- 本质上，一对主机进程之间的通信由2个端节点构成

#### 问题2：传输层提供的服务-需要穿过层间的信息
= 层间接口必须要携带的信息
  * 要传输的报文(对本层来说：SDU(Service Data Unit))
  * 谁串的：对方的应用进程的标识：IP+TCP(UDP)端口
  * 传给谁：对方的应用进程的标识: 对方的IP+TCP(UDP)端口
- 传输层实体(TCP或UDP实体) 根据这些信息进程TCP报文段(UDP数据报)的封装
  * 源端口号，目标端口号，数据等
  * 将IP地址往下交IP实体，用于封装IP数据报: 源IP，目标IP

- 如果Socket API每次传输报文，都携带很多信息，太繁琐，不便于管理
- 用个代号标示通信的双方或单方：Socket
- 就像OS打开文件返回的句柄一样
  * 对句柄的操作，就是对文件的操作
- TCP socket
  * TCP服务：两个进程之间的通信需要之前要建立连接
    - 两个进程通信会持续一段时间，通信关系稳定
  * 可以用一个整数表示两个应用实体之间的通信关系，```本地标示```
  * 穿过层间接口的信息量```最小```
  * TCP socket: 源IP，源端口，目标IP，目标端口

## TCP之上的套接字(socket)
- 对于使用面向连接服务(TCP)的应用而言，套接字是4元组的一个具有```本地意义的标示```
  * 4元组(源IP，源port，目标IP，目标port)
  * 唯一的指定了一个会话(2个进程之间的会话关系)
  * 应用使用这个标示，与远程的应用进程通信
  * 不必在每一个报文的发送都要指定这4元组
  * 就像使用操作系统打开一个文件，OS返回一个文件句柄一样，以后使用这个文件句柄，而不是使用这个文件的目录名，文件名
  * 简单，便于管理

## UDP socket
- UDP服务:两个进程之间的通信需要之前无需建立连接
  * 每个报文都是独立传播的
  * 前后报文可能给不同的分布式进程
- 因此，只能用一个整数表示本应用实体的标示
  * 因为这个报文可能传给另外一个分布式进程 1
- 穿过层间接口的信息大小最小
- UDP socket： 本IP，本port
- 但是传输报文时：必须要提供对方IP，port
  * 接收报文时: 传输层需要上传对方的IP，port

## UDP之上的套接字(socket)
- 对于使用无连接服务(UDP)的应用而言，套接字是2元组的一个具有```本地意义的标示```
  * 2元组：IP，port(源端指定)
  * UDP套接字制定了应用所在的一个```端节点(end point)```
  * 在发送数据报时，采用创建好的本地套接字(标示ID)，就不必在发送每个报文中指明自己所采用的IP和port
  * 但是在发送报文时，必须要指定对方的IP和UDP port(另外一个段节点)

## 套接字 (Socket)
- 进程向```套接字```发送报文或从套接字接收报文
- 套接字 <-> 门户
  * 发送进程将报文```推出```门户，发送进程依赖于传输层设施在另外一侧的门将报文交付给接收进程
  * 接收进程从另外一端的门户```收到```报文(依赖于传输层设施)

## 问题3：如何使用传输层提供的服务实现应用
- 定义应用层协议：报文格式，解释，时序等
- 编制服务，通过API调用网络基础设施提供通信服务传报文，解析报文，实现应用时序等


## 应用层协议
- 定义了：运行在不同端系统上的应用进程如何相互交换报文
  * 交换的```报文类型```:请求和应答报文
  * 各种报文类型的```语法```：报文中的各个字段及其描述
  * 字段的```语义```: 即字段取值的含义
  * 进程合适，如何发送报文及对报文进行响应的```规则```
- 应用协议仅仅是应用的一个组成部分
  * Web应用：HTTP协议，web客户端，web服务器，HTML

- 公开协议：
  * 由RFC文档定义
  * 允许互操作
  * 如HTTP，SMTP
- 专用(私有)协议：
  * 协议不公开
  * 如：Skype

## 应用层需要传输层提供什么样的服务？
- 数据丢失率
  * 有些应用则要求100%的可靠数据传输(如文件)
  * 有些应用(如音频)能容忍一定比例下的数据丢失
- 延迟
  * 一些应用出于有效性考虑，对数据传输由严格的时间限制
    * Internet电话，交互式游戏
    * 延迟，延迟差
- 吞吐
  * 一些应用(如多媒体)必须需要最小限度的吞吐，从而使得应用能够有效运转
  * 一些应用能充分利用可供使用的吞吐(弹性应用)
- 安全性
  * 机密性
  * 完整性
  * 可认证性(鉴别)


# Internet 传输层提供的服务
## TCP 服务
- 可靠的传输服务
- 流量控制：发送方不会淹没接收方
- 拥塞控制：当网络出现拥塞时，能抑制发送方
- 不能提供的服务
  * 时间保证，最小吞吐保证和安全
- 面向连接：
  * 要求在客户端进程和服务器进程之间建立连接

## UDP服务
- 不可靠数据传输
- 不提供的服务：
  * 可靠，流量控制，拥塞控制，时间，贷款保证，建立连接

## UDP存在的必要性
- 能够```区分不同的进程```,而IP服务不能
  * 在IP提供的主机到主机端到端功能的基础上，区分了主机的应用进程
- ```无需建立连接```
  * 省去了建立连接时间，适合事务性的应用
- ```不做可靠性的工作```,例如检错重发，适合对实时性要求高而对正确性要求不高的应用
  * 因为为了实现可靠性(准确性，保序等)，必须付出时间代价(检错重发)
- 没有拥塞控制和流量控制，```应用能够按照设定的速度发送数据```
  * 而TCP上的应用，应用发送数据的速度和主机向网络发送的实际速度是不同的，因为有流量控制和拥塞控制

## 安全TCP
- TCP & UDP
  * 都没有加密
  * 明文通过互联网传输，甚至密码
- SSL在应用层
  * 应用采用SSL库，SSL库使用TCP通信
- SSL (Secure Sockey Layer)
  * 在TCP上面实现，提供加密的TCP连接
  * 私密性
  * 数据完整性
  * 端到端的鉴别
- SSL socket API
  * 应用通过API将铭文交给socket，SSL将其加密在互联网上传输
  

## Web and HTTP
- 一些术语
  * ```Web页```：由一些```对象```组成
  * 对象可以是HTML文件，JPEG图像，Java小程序，声音剪辑文件等
  * Web页含有一个```基本的HTML文件```，该基本HTML文件又包含若干对象的引用(链接)
  * 通过```URL```对每个对象进行引用
    - 访问协议，用户名，口令字，端口等
  * URL格式

### HTTP 概况
- ```HTTP超文本传输协议```
  * Web的应用层协议
  * 客户/服务器模式
    - 客户：请求，接收和显示Web对象的浏览器
    - 服务器：对请求进行响应，发送对象的Web服务器
  - HTTP1.0: RFC 1945
  - HTTP1.1: RFC 2068

### HTTP概况(续)
- ```使用TCP```:
  * 客户发起一个与服务器的TCP连接(建立套接字)，端口号80
  * 服务器接受客户的TCO连接
  * 在浏览器(HTTP客户端)与Web服务器(HTTP服务器)交换HTTP报文(应用层协议报文)
  * TCP连接关闭

- ```HTTP是无状态的```
  * 服务器并不维护关于客户的任何信息

- ```维护状态的协议很复杂```
  * 必须维护历史信息(状态)
  * 如果服务器/客户端死机，它们的状态信息可能不一致,二者的信息必须一致
  * 无状态的服务器能够支持更多的客户端

### HTTP连接
- ```非持久HTTP```
  * 最多只有一个对象在TCP连接上发送
  * 下载多个对象需要多个TCP连接
  * HTTP/1.0使用非持久连接

- ```持久HTTP```
  * 多个对象可以在一个(在客户端和服务器之间的)TCP连接上传输
  * HTTP/1.1默认使用持久连接

### 响应时间模型
- ```往返时间RTT(round-trip-time):```
  * 一个小的分组从客户端到服务器，再回到客户端的时间(传输时间忽略)
- ```响应时间```
  * 一个RTT用来发起TCP连接
  * 一个RTT用来HTTP请求并等待HTTP响应
  * 文件传输时间
- ```共：2RTT + 传输时间```

### 持久HTTP
- ```非持久HTTP的缺点：```
  * 每个对象要2个RTT
  * 操作系统必须为每个TCP连接分配资源
  * 但浏览器通常打开并行TCP连接，以获取引用对象

- ```持久HTTP```
  * 服务器再发送响应后，仍保持TCP连接
  * 在相同客户端和服务器之间的后续请求和响应报文通过相同的连接进行传送
  * 客户端在遇到一个引用对象的时候，就可以尽快发送该对象的请求

- ```非流水方式的持久HTTP```
  * 客户端只能在收到前一个响应后才能发出新的请求
  * 每个引用对象花费一个RTT

- ```流水方式的持久HTTP```
  * HTTP/1.1的默认模式
  * 客户端遇到一个引用对象就立即产生一个请求
  * 所有引用(小)对象只花费一个RTT是可能的

- HTTP请求报文
  * 两种类型的HTTP报文：请求，响应
  * ```HTTP请求报文：```
    - ASCII(人能阅读)

### 提交表单输入
- ```POST方式：```
  * 网页通常包括表单输入
  * 包含在实体主体(entity body)中的输入被提交到服务器

- ```URL方式:```
  * 方法：GET
  * 输入```通过请求行的URL```字段上载

### 用户-服务器状态：cookies
- 大多数主要的门户网站使用 cookies
- ```cookie的4个组成部分```
  1. 在HTTP响应报文中有一个cookie的首部行
  2. 在HTTP请求报文含有一个cookie的首部行
  3. 在用户端系统中保留有一个cookie文件，由用户的浏览器管理
  4. 在Web站点由一个后端数据库

## Cookies(续)
- ```Cookies能带来什么：```
  * 用户验证
  * 购物车
  * 推荐
  * 用户状态(Web e-mail)

- ```如何维持状态```
  * 协议端节点：
    - 在多个事务上，发送端和接收端维持状态
  * cookies：HTTP报文携带状态信息

- ```Cookies与隐私：```
  * Cookies允许站点知道许多关于用户的信息
  * 可能将它知道的东西卖给第三方
  * 使用重定向和cookie的搜索引擎还能知道用户更多的信息
    - 如通过某个用户在大量站点上的行为，了解其个人浏览方式的大致模式
  * 广告公司从站点获得信息

## Web缓存(代理服务器)
- ```目标：```不访问原始服务器，就满足客户的请求
- 用户设置浏览器：通过缓存访问Web
- 浏览器将所有的HTTP请求发送给缓存
  * 在缓存中的对象：缓存直接返回对象
  * 如对象不在缓存，缓存请求原始服务器，然后再将对象返回给客户端

#### Web缓存
- 缓存既是客户端又是服务器
- 通常缓存是由ISP安装(大学，公司，居民区ISP)

- ```为什么要使用Web缓存```
  * 降低客户端的请求响应时间
  * 减少一个机构内部网络与Internent接入链路上的流量
  * 互联网大量使用了缓存：
    - 可以使较弱的ICP也能够有效提供内容

#### 条件GET方法
- 目标：如果缓存器中的对象拷贝是最新的，就不发送对象

- 缓存器：在HTTP请求中指定缓存拷贝的日期
  * If-modified-since: <date>

- 服务器：如果缓存拷贝陈旧，则响应报文没包含对象
  * HTTP/1.0 304 Not Modified
